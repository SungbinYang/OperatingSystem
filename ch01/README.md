> 이 포스트는 [널널한 개발자](https://www.inflearn.com/course/%EA%B3%B0%EC%B1%85-%EC%89%BD%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard)님의 강의를 듣고 작성한 글입니다.

## 인터럽트에서 DirectX까지

​

### 인터럽트

사전적 의미로 '끼어들다', '중단시키다' 정도의 의미를 가지는 말로 프로그램을 실행하는 도중에 예기치 않는 상황이 발생할 경우 현재 실행중인 작업을 멈추고 발생된 상황을 처리한 후 다시 실행중인 작업을 복귀하는 것을 말한다.
​

### 인터럽트의 종류

인터럽트의 종류는 외부 인터럽트, 내부 인터럽트, 소프트웨어 인터럽트로 나뉠 수 있다.
​

- 외부 인터럽트
  - 전원이상 인터럽트(Power faul interrupt): 말 그대로 정전 + 절전모드, 파워이상등
  - 기계착오 인터럽트(Machine check interrupt): CPU의 기능적 오류
  - 외부신호 인터럽트(External interrupt):
    - 타이머에 의한 인터럽트: Preemptive 개념을 생각하면 된다. 자원이 할당된 시간이 다 끝난 경우
    - 키보드로 인터럽트 키를 누른 경우: Control + Alt + Delete
    - 외부장치로부터 인터럽트 요청이 있는 경우: I/O 인터럽트 아님. 다른 개념임.
  - 입출력 인터럽트(I/O interrupt):
    - 입출력 장치가 데이터 전송을 요구하거나 전송이 끝나 다음 동작이 수행되어야 할 경우
    - 입출력 데이터에 이상이 있는 경우

CPU는 컴퓨터의 핵심적인 부품인데 CPU는 혼자서 작동하지 않고 주기억 장치 RAM과 밀접하게 연결되어 있다. 여기서 CPU가 RAM을 직접 통제할것이냐 아니면 간접적인 방식을 취할 것이냐인데 엄청 오래 전에는 직접 통제를 했지만 지금은 간접적인 방식을 사용하는데 무엇을 이용하여 사용하냐면 메모리 매니저(입출력 관리자)라는 칩을 이용한다. 이럴 때 발생하는게 입출력 인터럽트이다.

- 내부 인터럽트
  - 잘못된 명령이나 잘못된 데이터를 사용할 때 발생하며 Trap이라고 부른다.
  - 프로그램 검사 인터럽트
    - Division By Zero
    - Overflow / Underflow
    - 기타 Exception
  - 소프트웨어적인 내용이나 분류상 인터럽트가 아니다.
- 소프트웨어 인터럽트
  _ 사용자가 프로그램을 실행시키거나 감시 프로그램을 호출하는 동작을 하는 경우
  _ 소프트웨어 이용 중 다른 프로세스를 실행시키면 시분할 처리를 위해 자원 할당등의 동작 수행
  ​

### 인터럽트 동작 순서

1. 인터럽트 요청 -> 처리코드 작동!(ISR = 인터럽트 서비스 루틴) -> 이 코드가 완료될때 까지 정지!
2. 프로그램 실행 중단
   - 현재 실행 중이던 Micro Operation까지 수행된다.
3. 현재 프로그램 상태 보존
   - PCB(Process Control Block), PC(Porgram Counter)등
4. 인터럽트 처리 루틴 실행: 인터럽트를 요청한 장치를 식별.
5. 인터럽트 서비스 루틴 실행:
   인터럽트 원인을 파악하고, 실질적인 작업을 수행한다. 처리기 레지스터 상태를 보존한다. 서비스 루틴 수행 중 우선순위가 더 높은 인터럽트가 발생하면 또 재귀적으로 1~5를 수행한다.
6. 상태복구: 인터럽트 발생 시 저장해둔 PC를 다시 복구
7. 중단된 프로그램 실행 재개: PC값을 이용하여 이전에 수행중이던 프로그램을 제거
   ​

### 인터럽트 우선순위

여러 장치에서 인터럽트가 동시에 발생하거나 인터럽트 서비스 루틴 수행 중 인터럽트가 발생했을 경우 우선순위를 따져서 처리.
​
전원이상 > 기계착오 > 외부신호 > 입출력 > 명령어 잘못 > 프로그램 검사 > SVC
​
일반적으로 하드웨어 인터럽트가 소프트웨어 인터럽트보자 우선순위가 높고 내부인터럽트보다 외부 인터럽트가 우선순위가 높다.
​

### DirectX

​
​

- 좋은 CPU, RAM을 사도 안 좋은 메인보드를 사면 메모리 매니저가 안 좋기 때문에 CPU, RAM이 제 성능을 내기 어렵다.
- 과거의 Memory Manager를 Bridge Chipset이라고 불렸다.
  _ North Bridge: PCI-E, RAM, CPU I/O처리를 담당한다.
  _ South Bridge: PCI, USB, ISA, IDE, BIOS, Legacy등 주변기기 I/O를 담당한다.
  ​
  ​
  저번 포스팅에서 말했던 것처럼 API를 호출하면 write()가 커널 수준에서 System call이 일어나고 Data가 RAM에 들어간다. 이때 인터럽트가 발생하며,
  RAM의 Data를 주변기기에 이동시킬 때 인터럽트 발생하며, 이동 후, 끝났다고 인터럽트가 발생한다. 이러는 순간에 너무 많은 단계를 거쳐서 성능이 떨어지고 너무 시간이 오래걸린다.
  ​
  만일 게임을 한다고 가정한다면 게임자체가 동작하는데 느릴 것이다. 이럴 때 API가 직접 System call을 안 거치고 Driver를 조작가능하게 한 인터페이스를 만들었는데 그게 DirectX다.
  ​
  DirectX는 I/O 성능을 극단적으로 끌어올랄 수 있는 인터페이스로 예전 GDI 엔진을 사용하던 방식을 Window Vista 이후로 DirectX로 변경이되었다.

## DMA와 고성능 소켓

### DMA를 알면 고성능 소켓이 보인다.

위 그림은 저번 포스팅에서 이야기 했던 과정이다. 여기서 I/O 관리자는 CPU가 어떤 장치한테 뭔가를 직접 가져오면 장치가 반응이 늦을 것을 대비하여 I/O관리자가 도와준다. 또한 RAM의 일부를 Device를 위해 예약을 걸수도 있는데 이 과정에서 I/O관리자한테 알려준다.

### CPU가 어떤 장치한테 정보를 보내는 방법

1. CPU가 RAM의 예약된 메모리에 정보를 보낸다. (복사)
2. 어떤 경우는 데이터가 RAM의 내부에서 또 일어난다. (복사)
3. 복사된 데이터를 장치의 RAM에 또 복사한다.

이 모든 과정에서 I/O 매니저는 역할을 수행한다. 근데 의문점이 이렇게 복사하는게 아니라 한번에 CPU에서 Device로 보낼 수 있는 방법은 없을까?
CPU에서 Device로 한번에 보내거나 또는 CPU가 RAM의 일부를 복사할텐데 Device가 그 부분을 Direct로 Write한다. (I/O 매니저 없이) 바로 이 방법이 DMA이다. 이 이야기가 NIC(Network Interface Card)에서 많이 나온다.

### DMA

File에는 어떤 장치를 추상화한것이고 File에는 I/O 버퍼가 딸려있다. 여기서 데이터를 N/W를 통해 수신하는 경우 Kernel의 System call 부분이 TCP, IP로 나뉘고 이때 File을 Socket이라고 불린다.

H/W Device가 NIC라고 하면,

1. Process내의 네트워크로 송신할 데이터를 적재한다.
2. Process가 I/O 버퍼에 Write를 한다. 정확히는 Socket에다가 Send를 한다.
3. 그러면 네트워크 데이터가 I/O 버퍼에 적재된다.
4. Kernel 영역으로 내려오면서 Segmanation이 일어난다.
5. I/O 버퍼 데이터가 쪼개져서 Kernel 영역의 Buffer에 복사를 한다.
6. 커널 영역의 Buffer의 데이터를 NIC에 보내고 그걸 네트워크에 보낸다.

그런데 보면 이 Process 메모리, I/O Buffer, Kernel Buffer도 다 RAM 메모리이다. 즉, NIC가 DMA를 지원하면 수 많은 메모리를 안 거치고 바로 process 메모리로 간다. 예를 들어 C언어의 malloc 함수를 사용하여 할당을 받았다고 해보자. 할당받은 영역은 heap영역 어딘가일테고 이 메모리는 user mode application 메모리이다. 그런데 IOCP를 이용하면 heap 영역을 kernel에서 쓸꺼라고 OS가 Lock을 건다, 한마디로 찜이다. 즉, 과정이 단계를 안 거치고 바로 복사된다. 그 이유는 다 똑같은 RAM 메모리이기 때문이다.

더 대박인 경우는 가상화 클라우드 환경일때이다. A 클라우드에서 B 클라우드로 데이터를 송수신할때 가상화환경이고 NIC가 DMA를 지원하면 일종의 복사처럼 엄청 빨리 일어난다. 그 이유는 A클라우드, B클라우드 둘다 똑같은 RAM 메모리를 참조하기 때문이다.
